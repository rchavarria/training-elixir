# Hangman and Phoenix

## (Re)creating the Phoenix app with a Hangman connection

We're going to make our Phoenix app depend on our Hangman application

Where are we going to create the connection to Hangman? Based on the URL, so that each URL http://xx/hangman will be routed to our Hangman app in some way. Go and update `gallows/web/router.ex` file

Create a new *scope* for the route, a controller, a view and a template

Phoenix apps are created with a default `Page` controller/view/template. You’ll probably want to either delete or rename them in order to get your route (http://yourserver.com/hangman) working

## An initial server

We can save some data (such as the game state) in a (web) session. Phoenix uses encrypted cookies to store sessions. Cookies are sent back and forth between Phoenix and the browser.

`mix phx.routes` outputs all known routes in our app, for example:

```
hangman_path  GET   /hangman  GallowsWeb.HangmanController :new_game
hangman_path  POST  /hangman  GallowsWeb.HangmanController :create_game
```

`hangman_path` is a helper that will be available in the hangman view. It will create a link or an HTTP request to the right URL.

- `hangman_path(@conn, :new_game)` will create a GET request within a view
- `hangman_path(@conn, :create_game)` will create a POST request within a view

**What We Saw**

Avoid hand-coding HTML if helpers are available. They both add consistency and also automatically integrate into Phoenix.

The controller function invoked by an incoming request depends on both the incoming path and the HTTP verb used. A GET and a POST to the same URL look like two separate requests to Phoenix.

Sessions represent a history of interactions with a particular browser. Phoenix is flexible where the session data is stored—by default it is stored encrypted in a cookie in the browser. A session looks like a simple key/value store.

`put_session(conn, key, value)` returns a connection containing an updated session, and `get_session(conn, key)` returns a value from a session.

Try not to hard code URLs back into your application. Instead use the path helpers generated by the router.

**How To Find Helpers**

Path helpers are generated automatically by the definitions you add to the router. You can list them at the command prompt:

```
$ mix phx.routes
hangman_path  GET   /hangman  Gallows.Web.HangmanController :new_game
hangman_path  POST  /hangman  Gallows.Web.HangmanController :create_game
#-----------  ----  --------  ----------------------------- ------------
# helper      verb  path      controller                    function
```

Call a path helper, passing in the current connection and the name of the function, and it will return the path to use. It’s up to you to supply the verb.

**View Helpers**

There are a number of view-related helpers bundled into Phoenix. Have a look at


- [Helpers for working with HTML strings and templates](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html)
- [Helpers related to producing HTML tags within templates](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Tag.html)
- [Helpers related to producing HTML forms](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html)
- [Conveniences for working with links and URLs in HTML](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Link.html)
- [Helpers related to formatting text](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Format.html)

**Your Own Helpers**

A good rule of thumb is that an code more complex than a simple expression doesn’t belong in a template. Instead, encapsulate it into a helper and use the helper in the template.

Helpers are just functions, and so you can put them anywhere, and you can share them between templates. By default, **a view is created for each controller, and functions defined in that view will be available to all templates for that controller**. A view can use import to include the functions in another module (useful for sharing helpers between controllers) and a template can explicitly reference helpers outside its view by using the full module/function name.

## Add a form

To add a form, please, use a helper. It fills some structures Phoenix knows about, it covers against some security issues (cross session forgery blah blah)

We previously used HTTP GET and POST verbs. In this unit we used PUT, because we wanted to modify existing data (the game state).

**Where Form Data Goes**

A Phoenix `form_for` helper can construct an HTML form that will be initially populated by data send from your Phoenix controller, and which can send data back to the controller when the form is submitted.

Out of the box, there are two built-in strategies for managing this data. One works with Ecto changesets, so that forms can interoperate fairly seamlessly with data held in databases.

The other strategy keeps form data in the connection value. In this scheme, form data is treated in the same way as parameters that can be passed via the incoming request.

**Request Parameters**

HTTP lets you add a query string to a request: `http://example.com/lookup?term=wombat&type=image`

If you sent this request to a Phoenix application, the controller function handling it would receive a params parameter containing the query string, broken down into a map:

```
def lookup(conn, params) do
  raise inspect(params)        # => %{ "term" => "wombat, "type" => "image" }
end
```

You can even pass parameters which create nested maps: `http://example.com/lookup?name[first]=Dave&name[last]=Thomas`

```
def lookup(conn, params) do
  raise inspect(params)        # => %{ "name" => %{
end                                        "first" => "Dave",
                                           "last"  => "Thomas"
                                            }
                                      }
```

Finally you can specify parameters by associating elements in the path with names. This is done in your routes: `get "/lookup/:first/:last", .....`

You can look that up in the Phoenix documentation.

**Back to Forms**

Another way to populate params is using a submitted form. Each field in the form has a name and a value, and those are used to populate a map when the form is submitted. When you create the form using `form_for`, you use the `as:` name option to specify a name for that map.

For example, here’s a form with the name `make_move` containing a text field named `guess`.

```
<%= form_for(@conn, "/lookup", [ as: :make_move,], fn form -> %>
  <%= text_input(form, :guess) %>
  <%= submit("Make next move") %>
<% end) %>
```

Data from this form would appear in the `params` map like this:

```
def lookup(conn, params) do
  raise inspect(params)        # => %{ "make_move" => %{
end                                        "guess" => "x"
                                            }
                                     }
```

Similarly, if you call `render` and the connection parameters contains values corresponding to form fields, the HTML form will use them as initial values.

## More complex helpers

Think hard before substituting values into strings that will be sent to the browser without escaping. This practice can be a major security hole. Just about the only time you can get away with it is when the strings are private constants stored in your code.

`raw(str)` (inside a View) is the same as `{:safe, str}`—both disable HTML escaping or strings. Following on from the previous point, whenever you use on of these, accept that you might be opening the security hole that gets your app free publicity on the nightly news.

Because built-in helpers are just functions that are imported into views, they are available to the helpers that you write in that view. This means your helpers can wrap and extent the standard ones, such as `button` and `form_for`.

Complex helper logic in your views should be split into its own module. This module can be placed anywhere; my preference is `views/helpers`.

Helpers extracted in this way will not longer be in the view module directly, and therefore won’t have the built-in helpers automatically available. However, you can import them directly and they’ll just work.

**A Personal Rant About Single Responsibility Principle**

I know I’m like a broken record, but I can’t help it. I’m really excited to see how a functional approach makes it so much easier to honor the SRP, both at the function and module level. The fact that state is passed around, and not simply shared, means that functions can and modules can both be split and moved around.

Take advantage of this to keep your all your code neat, tidy, and to the point.

## Wrapping up: adding graphics

